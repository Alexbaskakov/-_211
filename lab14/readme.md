Для того чтобы разобраться с тем, о чём мы будем тут говорить, вам будет полезно освежить в памяти то, о чём шла речь в предыдущих лабораторных работах.
А именно, об инструкциях файлов Dockerfile. 
Знание этих инструкций и тех особенностей Docker, которые мы обсудим сегодня, поможет вам оптимизировать файлы образов Docker.

# Кэширование

Одной из сильных сторон Docker является кэширование. Благодаря этому механизму ускоряется сборка образов.

При сборке образа Docker проходится по инструкциям файла Dockerfile, выполняя их по порядку. 
В процессе анализа инструкций Docker проверяет собственный кэш на наличие в нём образов, представляющих собой то, что получается на промежуточных этапах сборки других образов.
Если подобные образы удаётся найти, то система может ими воспользоваться, не тратя время на их повторное создание.

Если кэш признан недействительным, то инструкция, в ходе выполнения которой это произошло, выполняется, создавая новый слой без использования кэша.
То же самое происходит и при выполнении инструкций, которые следуют за ней.

В результате, если в ходе выполнения инструкций из Dockerfile оказывается, что базовый образ имеется в кэше, то используется именно этот образ из кэша.
Это называется «попаданием кэша». Если же базового образа в кэше нет, то весь процесс сборки образа будет происходить без использования кэша.

Затем следующая инструкция сопоставляется со всеми образами из кэша, в основе которых лежит тот же самый базовый образ, который уже обнаружен в кэше.
Каждый кэшированный промежуточный образ проверяется на предмет того, имеется ли в нём то, что было создано такой же инструкцией.
Если совпадения найти не удаётся, это называется «промахом кэша» и кэш считается недействительным.
То же самое происходит до тех пор, пока не будет обработан весь файл Dockerfile.

Большинство новых инструкций просто сравниваются с тем, что уже есть в промежуточных образах.
Если системе удаётся найти совпадение, то при сборке используется то, что уже есть в кэше.

Использование кэша способно ускорить сборку образов, но тут есть одна проблема.
Например, если в Dockerfile обнаруживается инструкция `RUN pip install -r requirements.txt`, то Docker выполняет поиск такой же инструкции в своём локальном
кэше промежуточных образов. При этом содержимое старой и новой версий файла requirements.txt не сравнивается.

Подобное может приводить к проблемам в том случае, если в requirements.txt были добавлены сведения о новых пакетах, после чего, при сборке обновлённого образа, для того, чтобы установить новый набор пакетов, нужно снова выполнить инструкцию RUN pip install. Совсем скоро мы поговорим о том, как бороться с этой проблемой.

В отличие от других инструкций Docker, при выполнении инструкций ADD и COPY от Docker требуется проверка содержимого файла или файлов для определения того, можно ли, при формировании образа, воспользоваться кэшем. А именно, контрольная сумма файлов, упомянутых в этих инструкциях, сравнивается с контрольной суммой файлов, которые имеются в промежуточных образах, которые уже есть в кэше. Если изменилось содержимое файлов или их метаданные, тогда кэш признаётся недействительным.

Вот несколько советов, касающихся эффективного использования кэша Docker:

Кэширование можно отключить, передав ключ --no-cache=True команде docker build.
Если вы собираетесь вносить изменения в инструкции Dockerfile, тогда каждый слой, созданный инструкциями, идущими после изменённых,
будет достаточно часто собираться повторно, без использования кэша. Для того чтобы воспользоваться преимуществами кэширования,
помещайте инструкции, вероятность изменения которых высока, как можно ближе к концу Dockerfile.
Объединяйте команды `RUN apt-get update` и `apt-get install` в цепочки для того, чтобы исключить проблемы, связанные с неправильным использованием кэша.
Если вы используете менеджеры пакетов, наподобие `pip`, с файлом requirements.txt, тогда придерживайтесь нижеприведённой схемы работы для того,
чтобы исключить использование устаревших промежуточных образов из кэша, содержащих набор пакетов, перечисленных в старой версии файла requirements.txt.
Вот как это выглядит:

```
COPY requirements.txt /tmp/
RUN pip install -r /tmp/requirements.txt
COPY . /tmp/
```

Если вам известны другие способы борьбы с «проблемой requirements.txt» — можете рассказать о них в отчете.

## Уменьшение размеров образов

▍Тщательный подбор базового образа

Образы Docker могут быть довольно большими. Это противоречит вполне обоснованному стремлению того, кто их создаёт,
к тому, чтобы сделать их как можно более компактными, что облегчит их загрузку из удалённого репозитория и благотворно
скажется на объёме свободного места на компьютере, на который они загружаются. Поговорим о том, как уменьшать их размеры.

Одним из способов уменьшения размеров образов является тщательный подбор базовых образов и их последующая настройка.

Так, например, базовый образ Alpine представляет собой полноценный дистрибутив Linux-подобной ОС,
содержащий минимум дополнительных пакетов. Его размер — примерно 5 мегабайт. 
Однако сборка собственного образа на основе Alpine потребует потратить достаточно много времени на то,
чтобы оснастить его всем необходимым для обеспечения работы некоего приложения.

Существуют и специализированные варианты базового образа Alpine. Например,
соответствующий образ из репозитория python, в который упакован скрипт `print("hello world")`
весит около 78.5 Мб. Вот Dockerfile для сборки такого образа:

```
FROM python:3.7.2-alpine3.8
COPY . /app
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]
```

При этом на Docker Hub сказано, что этот базовый образ имеет размер 29 Мб.
Размер образа, основанного на этом базовом образе, увеличивается за счёт загрузки и установки Python.

Помимо использования базовых образов, основанных на Alpine, уменьшить размеры образов можно благодаря использованию технологии многоступенчатой сборки.

## Многоступенчатая сборка образов

В Dockerfile, описывающем многоступенчатую сборку образа,
используется несколько инструкций `FROM`. Создатель такого образа может настроить выборочное копирование файлов,
называемых артефактами сборки, из одной ступени сборки в другую ступень. При этом появляется возможность избавиться
от всего того, что в готовом образе не понадобится. Благодаря этому методу можно уменьшить размер готового образа.

Вот как работает каждая инструкция `FROM`:

- Она начинает новый шаг сборки.
- Она не зависит от того, что было создано на предыдущем шаге сборки.
- Она может использовать базовый образ, отличающийся от того, который применялся на предыдущем шаге.

Вот модифицированный пример файла Dockerfile из документации Docker, описывающего многоступенчатую сборку.

```
FROM golang:1.7.3 AS build
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=build /go/src/github.com/alexellis/href-counter/app .
CMD ["./app"]
```


Обратите внимание на то, что мы дали имя первой ступени сборки, указав его после инструкции `FROM`.
К именованному этапу сборки мы обращаемся в инструкции `COPY --from=` ниже в Dockerfile.

Применение процесса многоступенчатой сборки образов имеет смысл в некоторых случаях,
когда приходится создавать множество контейнеров для продакшн-окружения. Многоступенчатая сборка позволяет максимально сократить
размеры готовых образов. Но иногда такой подход приводит к усложнению поддержки образов. Поэтому вы, вероятно, не
будете пользоваться многоступенчатой сборкой образов в тех случаях, в которых без неё можно обойтись. Об особенностях этой технологии можно почитать здесь и здесь.

Как видите, многоступенчатая сборка — технология интересная, но подходит она далеко не для всех случаев.
Тот же способ уменьшения размера образов, который мы обсудим ниже, можно порекомендовать абсолютно всем.

## Файл .dockerignore

О файлах .dockerignore нужно знать абсолютно всем, кто хочет освоить Docker. Эти файлы похожи на файлы .gitignore.
Они содержат список файлов и папок, в виде имён или шаблонов, которые Docker должен игнорировать в ходе сборки образа.

Этот файл размещают там же, где находится файл Dockerfile, и всё остальное, входящее в контекст сборки образа.

При запуске команды `docker build`, инициирующей сборку образа, Docker проверяет папку на наличие в ней файла .dockerignore.
Если такой файл найти удаётся, тогда этот файл разбирается, при этом при определении списка файлов, которые нужно игнорировать,
используются правила функции `Match()` из пакета filepath Go и некоторые собственные правила Docker.

Так, например, если в файле .dockerignore встретится шаблон вида *.jpg, то при создании образа проигнорированы будут файлы
с любым именем и с расширением .jpg. Если в файле встретится строка videos, то система проигнорирует папку videos и всё её содержимое.

При составлении файла .dockerignore его можно снабжать комментариями, используя символ #.

Вот что даёт тому, кто занимается созданием образов Docker, применение файлов .dockerignore:

- Это позволяет исключать из состава образа файлы, содержащие секретные сведения наподобие логинов и паролей.
- Это позволяет уменьшить размер образа. Чем меньше в образе файлов — тем меньше будет его размер и тем быстрее с ним можно будет работать.
- Это даёт возможность уменьшить число поводов для признания недействительным кэша при сборке похожих образов.
- Например, если при повторной сборке образа меняются некие служебные файлы проекта, наподобие файлов с журналами, из-за чего данные,
- хранящиеся в кэше, по сути, необоснованно признаются недействительными, это замедляет сборку образов.

Подробности о файле .dockerignore можно почитать в документации к Docker.

## Исследование размеров образов

Поговорим о том, как, пользуясь средствами командной строки, узнавать размеры образов и контейнеров Docker.

- Для того чтобы выяснить примерный размер выполняющегося контейнера, можно использовать команду вида `docker container ls -s`.
- Команда `docker image ls` выводит размеры образов.
- Узнать размеры промежуточных образов, из которых собран некий образ, можно с помощью команды `docker image history my_image:my_tag`.
- Команда `docker image inspect my_image:tag` позволяет узнать подробные сведения об образе, в том числе — размер каждого его слоя.
Слои немного отличаются от промежуточных образов, из которых состоит готовый образ, но, в большинстве случаев их можно рассматривать
как одинаковые сущности. Вот хороший материал, который посвящён подробностям внутреннего устройства образов Docker.
- Для того чтобы исследовать содержимое контейнеров можно установить пакет `dive`.

Теперь, когда мы обсудили возможности по уменьшению размеров образов, предлагаю вашему вниманию восемь рекомендаций,
касающихся уменьшения размеров образов и ускорения процесса их сборки.

## Рекомендации по уменьшению размеров образов и ускорению процесса их сборки

Используйте всегда, когда это возможно, официальные образы в качестве базовых образов.
Официальные образы регулярно обновляются, они безопаснее неофициальных образов.
Для того чтобы собирать как можно более компактные образы, пользуйтесь базовыми образами, основанными на Alpine Linux.
Если вы пользуетесь apt, комбинируйте в одной инструкции RUN команды `apt-get update и apt-get install`.
Кроме того, объединяйте в одну инструкцию команды установки пакетов.
Перечисляйте пакеты в алфавитном порядке на нескольких строках, разделяя список символами \. Например, это может выглядеть так:

```
RUN apt-get update && apt-get install -y \
    package-one \
    package-two \
    package-three
 && rm -rf /var/lib/apt/lists/*
```

Этот метод позволяет сократить число слоёв, которые должны быть добавлены в образ, и помогает поддерживать код файла в приличном виде.
Включайте конструкцию вида `&& rm -rf /var/lib/apt/lists/*` в конец инструкции `RUN`, используемой для установки пакетов.
Это позволит очистить кэш apt и приведёт к тому, что он не будет сохраняться в слое, сформированном командой RUN. Подробности об этом можно почитать в документации.
Разумно пользуйтесь возможностями кэширования, размещая в Dockerfile команды, вероятность изменения которых высока, ближе к концу файла.
Пользуйтесь файлом .dockerignore.
Взгляните на dive — отличный инструмент для исследования образов Docker, который помогает в деле уменьшения их размеров.
Не устанавливайте в образы пакеты, без которых можно обойтись.

# Задание 1:

Следуя рекомендациям из теоретической части работы, уменьшите образ контейнера для одной из предыдущих лабораторных работ.


## Шпаргалка по командам Docker

- Команды интерфейса командной строки Docker, используемые для управления чем-либо, начинаются с ключевого слова docker,
за которым идёт пробел, затем идёт указание на то, на что именно будет направлена некая команда, потом ещё один пробел,
а потом следует сама команда. Например, именно так построена такая команда: `docker container stop`.
- Если команда направлена на конкретный образ или контейнер, то в ней используется имя или идентификатор такого образа или контейнера.

Например, команда `docker container run my_app` — это команда для создания и запуска контейнера с именем my_app.
В примерах, которые будут приведены ниже, контейнеры мы будем называть my_container, образы — my_image, теги — my_tag, и так далее.

Сначала мы будем рассматривать саму команду, потом — флаги,
которые можно с ней использовать, если такие флаги существуют. Если перед флагом стоит два тире — то это его полная форма,
флаг с одним тире — это сокращённый вариант некоего флага. Действуют они одинаково. Например, `-p` — это сокращённая форма флага `--port`.

Цель этого материала заключается в том, чтобы дать вам общие сведения о командах Docker.
Так вы, имея общее представление о них и зная о возможностях платформы, доступных благодаря этим командам,
сможете, при необходимости, найти подробные сведения о них. Команды, о которых пойдёт речь, испытаны на ОС
семейства Linux с использованием движка Docker версии 18.09.1 и API версии 1.39.

### Примечание о командах, поддерживаемых Docker CLI 1.13

В интерфейсе командной строки Docker версии 1.13 представлены обновлённые, логически сгруппированные команды.
При этом старые команды всё ещё работают, но новыми пользоваться легче, особенно — начинающим.
Речь идёт, например, о том, что в версии 1.12 использовалась команда вида `docker create`, а в версии 1.13 стала доступна команда `docker container create`.
Сведения о соответствии старых и новых команд можно найти [здесь](http://blog.arungupta.me/docker-1-13-management-commands/).

Сначала мы посмотрим на команды, предназначенные для управления контейнерами, затем обсудим управление образами.

#### Команды для управления контейнерами

Общая схема команд для управления контейнерами выглядит так:

`docker container my_command`

Вот команды, которые могут быть подставлены туда, где мы использовали my_command:

- `create` — создание контейнера из образа.
- `start` — запуск существующего контейнера.
- `run` — создание контейнера и его запуск.
- `ls` — вывод списка работающих контейнеров.
- `inspect` — вывод подробной информации о контейнере.
- `logs` — вывод логов.
- `stop` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGTERM, и, через некоторое время, SIGKILL.
- `kill` — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGKILL.
- `rm` — удаление остановленного контейнера.

#### Команды для управления образами

Для управления образами используются команды, которые выглядят так:

`docker image my_command`

Вот некоторые из команд этой группы:

- `build` — сборка образа.
- `push` — отправка образа в удалённый реестр.
- `ls` — вывод списка образов.
- `history` — вывод сведений о слоях образа.
- `inspect` — вывод подробной информации об образе, в том числе — сведений о слоях.
- `rm` — удаление образа.

#### Разные команды

`docker version` — вывод сведений о версиях клиента и сервера Docker.
`docker login` — вход в реестр Docker.
`docker system prune` — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.

Теперь рассмотрим эти команды подробнее.

Начало существования контейнера

На начальном этапе работы с контейнерами используются команды `create`, `start` и `run`. Они применяются, соответственно, для создания контейнера,
для его запуска, и для его создания и запуска.

Вот команда для создания контейнера из образа:

`docker container create my_repo/my_image:my_tag`

В следующих примерах конструкция my_repo/my_image:my_tag будет сокращена до my_image.
Команда create принимает множество флагов. Например, её можно записать в таком виде:

`docker container create -a STDIN my_image`

Флаг -a представляет собой краткую форму флага --attach. Этот флаг позволяет подключить контейнер к STDIN, STDOUT или STDERR.

После того, как контейнер создан, его можно запустить следующей командой:

`docker container start my_container`

Обратите внимание на то, что сослаться на контейнер в команде можно либо используя его ID, либо имя.

Теперь взглянем на команду, которая позволяет создать и запустить контейнер:

`docker container run my_image`

Эта команда тоже способна принимать множество аргументов командной строки. Рассмотрим некоторые из них на примере такой конструкции:

`docker container run -i -t -p 1000:8000 --rm my_image`

- Флаг -i — это сокращение для --interactive. Благодаря этому флагу поток STDIN поддерживается в открытом состоянии даже если контейнер к STDIN не подключён.

- Флаг -t — это сокращение для --tty. Благодаря этому флагу выделяется псевдотерминал, который соединяет используемый терминал с потоками STDIN и STDOUT контейнера.

- Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги -i и -t.

- Флаг -p представляет собой сокращение для --port. Порт — это интерфейс, благодаря которому контейнер взаимодействует с внешним миром. Конструкция 1000:8000 перенаправляет порт Docker 8000 на порт 1000 компьютера, на котором выполняется контейнер. Если в контейнере работает некое приложение, способное выводить что-то в браузер, то, для того, чтобы к нему обратиться, в нашем случае можно перейти в браузере по адресу localhost:1000.

- Флаг --rm автоматически удаляет контейнер после того, как его выполнение завершится.

Рассмотрим ещё некоторые примеры команды run:

`docker container run -it my_image my_command`

В подобной конструкции может применяться команда sh, которая создаст сессию терминала в контейнере, с которой можно взаимодействовать через ваш терминал. При работе с образами, основанными на Alpine, лучше ориентироваться на использование sh а не bash, так как в этих образах, по умолчанию, оболочка bash не установлена. Для выхода из интерактивной сессии воспользуйтесь командой exit.

Обратите внимание на то, что здесь мы скомбинировали флаги -i и -t в -it.

Вот ещё один пример работы с командой run:

`docker container run -d my_image`

Флаг -d — это сокращение для --detach. Эта команда запускает контейнер в фоновом режиме. Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.

####Проверка состояния контейнера

Если у вас имеются запущенные контейнеры Docker и вы хотите узнать о том, что это за контейнеры, вам понадобится вывести их список. Сделать это можно такой командой:

`docker container ls` (в новых версиях команда имеет прямую ссылку или заменена уже знакомой вам командой `docker ps`)

Эта команда выводит список выполняющихся контейнеров и снабжает этот список некоторыми полезными сведениями о них. Вот ещё один пример этой команды:

`docker container ls -a -s`

Ключ -a этой команды — это сокращение для --all. Благодаря использованию этого ключа можно вывести сведения обо всех контейнерах, а не только о выполняющихся.

Ключ -s — это сокращение для --size. Он позволяет вывести размеры контейнеров.

Вот команда, которая выводит подробные сведения о контейнере:

`docker container inspect my_container`

Вот команда, выводящая логи контейнера:

`docker container logs my_container`

#### Завершение работы контейнера

Иногда работающий контейнер надо остановить. Для этого используется такая команда:

`docker container stop my_container` 

Она позволяет останавливать работающие контейнеры, позволяя им корректно завершить работу. У контейнера есть, по умолчанию, 10 секунд, на то, чтобы завершить работу.

Если же контейнер нужно остановить быстро, не заботясь о корректном завершении его работы, можно воспользоваться такой командой:

`docker container kill my_container`

Команда kill, если сравнить работающий контейнер с включенным телевизором, напоминает выключение телевизора путём отключения его от электричества. Поэтому, в большинстве ситуаций, для остановки контейнеров рекомендуется использовать команду stop.

Вот команда, которая позволяет быстро остановить все работающие контейнеры:

`docker container kill $(docker ps -q)` 

Для удаления остановленного контейнера можно воспользоваться такой командой:

`docker container rm my_container`

Вот команда, которая позволяет удалить все контейнеры, которые на момент вызова этой команды не выполняются:

`docker container rm $(docker ps -a -q)`

Подведём итоги этого раздела. Сначала контейнер создают, потом его запускают, или комбинируют эти два шага, используя команду вида `docker run my_container`.
После этого запускается контейнеризированное приложение.

Потом контейнер останавливают командой `docker stop my_container`. Для удаления контейнера используется команда `docker rm my_container`.

Поговорим теперь о командах, используемых для работы с образами, с теми самыми шаблонами, из которых создают контейнеры.

#### Создание образов

Вот команда, которая позволяет собирать образы Docker:

`docker image build -t my_repo/my_image:my_tag` .

В данном случае создаётся образ с именем my_image, при его сборке используется файл Dockerfile, находящийся по указанному пути или URL.

Флаг -t — это сокращение для --tag. Он указывает Docker на то, что создаваемому образу надо назначить предоставленный в команде тег. В данном случае это my_tag.

Точка в конце команды указывает на то, что образ надо собрать с использованием файла Dockerfile, находящегося в текущей рабочей директории.

После того, как образ собран, его можно отправить в удалённый реестр. Благодаря этому им смогут воспользоваться другие люди, его можно будет загрузить и запустить на другом компьютере. Предположим, вы хотите использовать Docker Hub. Если так — вам понадобится завести там учётную запись. Пользоваться этим ресурсом можно бесплатно.

После того, как вы зарегистрируетесь на Docker Hub, вам нужно войти в систему. И хотя команда, которая для этого используется,
напрямую к командам, предназначенным для работы с образами, не относится, её полезно будет рассмотреть именно здесь. Речь идёт о следующей команде:

`docker login`

Она позволяет войти в учётную запись на Docker Hub. Для входа в систему вам понадобится ввести имя пользователя и пароль.

После входа в систему можно будет отправлять образы в реестр. Делается это так:

`docker image push my_repo/my_image:my_tag`

Теперь, когда у вас наберётся несколько образов, вы можете их исследовать с помощью специальных команд.

####Исследование образов

Вот команда, которая выводит список образов, выводя, в том числе, и сведения об их размере:

`docker image ls`

Следующая команда позволяет вывести сведения о промежуточных образах, входящих в состав образа, в частности — данные об их размерах и о том, как они были созданы:

`docker image history my_image`

Вот команда, которая выводит подробные сведения об образе, в том числе — данные о слоях, из которых состоит образ:

`docker image inspect my_image`

Если вы создадите очень много образов, может случиться так, что некоторые из них понадобится удалить.

#### Удаление образов

Вот команда, которая позволяет удалить указанный образ:

`docker image rm my_image`

Если образ хранится в удалённом репозитории, он оттуда удалён не будет.

Вот команда, которая позволяет удалить все локальные образы:

`docker image rm $(docker images -a -q) `

Пользоваться этой командой стоит с осторожностью, но надо заметить, что при её использовании образы, хранящиеся в удалённом репозитории, удалены не будут. В этом заключается одно из преимуществ хранения образов в репозиториях.

Мы рассмотрели основные команды, используемые для управления контейнерами и образами. Поговорим теперь ещё о некоторых командах.

#### Разные команды

Вот команда, которая выводит сведения о версиях клиента и сервера Docker:

`docker version`

Эта, уже известная вам команда, применяется для входа в реестр Docker:

`docker login`

Такая команда позволяет удалить неиспользуемые контейнеры, сети и образы, которым не назначено имя и тег:

`docker system prune`

Вот пример её использования:

`docker system prune -a --volumes`

Ключ -a — сокращение для --all, позволяет удалить неиспользуемые образы, а не только те, которым не назначено имя и тег.

Ключ --volumes позволяет удалить неиспользуемые тома.


